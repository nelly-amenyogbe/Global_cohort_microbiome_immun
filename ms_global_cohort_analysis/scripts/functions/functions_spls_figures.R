###################
# Nelly Amenyogbe
# 17-Apr-2018
# Functions to generate heatmaps and networks from correlation result tables
##################


# This function is for the global cohort data specifically, and returns a network labelleing OTUs by genus-level classification and colouring by phylum, with labelling cytokines as cytokines and colouring by stimulus.

# require
#library(plyr)
#library(dplyr)


# function get.feature.data ####
# require taxonomy file:
#taxonomy <- read.csv("ms_global_cohort_analysis/Rdata/human_raw_data/gc_taxonomy_table.csv")
# Format the taxonomy file so that the names column matches the feature names in the X data.

# require phylum and stim cols:
# requires phylum and stim cols:
#phy.cols <- read.csv("ms_global_cohort_analysis/Rdata/graph_aesthetics/gc_phylum_cols.csv")
#stim.cols <- read.csv("ms_global_cohort_analysis/Rdata/graph_aesthetics/gc_stim_cols.csv")

# Input global cohort spls object with X = OTU or aggregate table, and Y = cytokine data with columns labelled ck_stim
# Output: list of 2.  metadata for features selected by sPLS.  For OTUs this will incude the taxonomic assignment, and for cytokines the stimulus and cytokines

get.feature.data <- function(spls.object, x.meta){

  # Get OTU metadata
  X.feat <- colnames(spls.object$X)
  
  X.meta <- x.meta
  X.meta <- filter(X.meta, names %in% X.feat)
  
  # Get X plotting colours
  phyla <- filter(phy.cols, Phylum %in% X.meta$Phylum)
  X.meta$Phylum <- factor(X.meta$Phylum, levels = c(as.character(phy.cols$Phylum)))
  
  X.meta <- join(X.meta, phyla, by = "Phylum")
  
  # Get cytokine metadata
  Y.feat <- colnames(spls.object$Y)
  
  Y.meta <-  data.frame(do.call('rbind', strsplit(as.character(Y.feat),'_',fixed=TRUE)))
  colnames(Y.meta) <- c("Cytokine", "Stimulus")
  Y.meta$names <- Y.feat
  
  # Add cytokine colours
  stims <- filter(stim.cols, Stim %in% Y.meta$Stimulus)
  colnames(stims)[2] <- "Stimulus"
  Y.meta$Stimulus <- factor(Y.meta$Stimulus, levels = as.character(stims$Stim))
  
  Y.meta <- join(Y.meta, stims[,c("Stimulus", "stim.cols", "shape")], by = "Stimulus")
  
  # return relevant data
  to.return <- list(X.meta, Y.meta)
  names(to.return) <- c("X.meta", "Y.meta")
  return(to.return)
}


# function spls.cor.circle ####
# requires phylum and stim cols:
#phy.cols <- read.csv("Rdata/gc_phylum_cols.csv")
#stim.cols <- read.csv("Rdata/gc_stim_cols.csv")

# Input: spls.object = output of mixOmics::spls()
# x.meta: metadata generated by get.feature.data above
# y.meta: metadata generated by get.feature.data above
# comps: model components to plot  (e.g. c(1,2) for components 1 and 2)

spls.cor.circle <- function(spls.object, x.meta, y.meta, comps){
  
  # get correlation circle data
  cor.c.dat <- plotVar(spls.object, comp = comps, plot = FALSE)
  cor.c.dat <- as.data.frame(cor.c.dat)
  cor.c.dat$Data <- ifelse(cor.c.dat$Block == "X", "OTU", "Cytokine")
  
  # separate block data
  cor.X <- filter(cor.c.dat, Block == "X") # OTU data
  cor.Y <- filter(cor.c.dat, Block == "Y") # Cytokine data
  
  # add metadata to X/Y dat
  cor.X <- join(cor.X, x.meta, by = "names")
  cor.Y <- join(cor.Y, y.meta, by = "names")
  
  # make plot colours
  # phylum
  phylum.cols <- as.character(phy.cols$phylum.cols)
  names(phylum.cols) <- phy.cols$Phylum
  phylum.cols <- phylum.cols[which(names(phylum.cols) %in% cor.X$Phylum)]
  
  # stim
  stimulus.cols <- as.character(stim.cols$stim.cols)
  names(stimulus.cols) <- stim.cols$Stim
  stimulus.cols <- stimulus.cols[which(names(stimulus.cols) %in% cor.Y$Stimulus)]
  
  # make your own correlation circle
  circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
    r = diameter / 2
    tt <- seq(0,2*pi,length.out = npoints)
    xx <- center[1] + r * cos(tt)
    yy <- center[2] + r * sin(tt)
    return(data.frame(x = xx, y = yy))
  }
  
  outer.circle <- circleFun(c(0,0),2,npoints = 100)
  inner.circle <- circleFun(c(0,0),1,npoints = 100)
  
  # plot
  p <- ggplot() +
    geom_path(data = outer.circle, aes(x = x, y = y)) +
    geom_path(data = inner.circle, aes(x = x, y = y)) +
    geom_point(data = cor.X, aes(x = x, y = y, colour = Phylum), alpha = 0.7, size = 3, show.legend = TRUE, shape = 19) +
    geom_text(data = cor.X, size = 2, aes(x = x, y = y, label = Genus), nudge_x = 0.12) +
    geom_point(data = cor.Y, aes(x = x, y = y, fill = Stimulus), alpha = 0.7, size = 3, show.legend = TRUE, shape = 24, color = "white") +
    geom_text(data = cor.Y, size = 2, aes(x = x, y = y, label = Cytokine), nudge_x = 0.05) +
    geom_hline(yintercept = 0.0, linetype = "dashed", color = "grey") + 
    geom_vline(xintercept = 0.0, linetype = "dashed", color = "grey") + 
    theme_bw() + 
    labs(x = paste("Component", comps[1]), y = paste("Component", comps[2])) +
    scale_color_manual("Phylum", values = c(phylum.cols),
                       guide = guide_legend(override.aes = list(colour = c(phylum.cols), shape = 19))) +
    scale_fill_manual("Stimulus",
                      values = c(stimulus.cols),
                      guide = guide_legend(override.aes = list(fill = c(stimulus.cols), shape = 24, colour = "white"))) +
    theme(panel.border = element_rect(size = 1.5),
          strip.background = element_rect(fill = "white", size = 1.5),
          strip.text.x = element_text(size = 12, face = "bold"),
          axis.text.x = element_text(size = 12, face = "bold"),
          axis.text.y = element_text(size = 12, face = "bold"),
          axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14),
          legend.text = element_text(size = 12),
          legend.title = element_text(size = 12))
  
  return(p)
}

# function cor.circle.sig ####
# This function performs the same task as the above, but allows to reduce the features included in the plot according to a user-defined list supplied by x.features and y.features as character vectors.


cor.circle.sig <- function(spls.object, x.features, y.features, x.meta, y.meta, comps){
  
  # get correlation circle data
  cor.c.dat <- plotVar(spls.object, comp = comps, plot = FALSE)
  cor.c.dat <- as.data.frame(cor.c.dat)
  cor.c.dat$Data <- ifelse(cor.c.dat$Block == "X", "OTU", "Cytokine")
  
  # separate block data
  cor.X <- filter(cor.c.dat, Block == "X") # OTU data
  cor.X <- filter(cor.X, names %in% x.features)
  
  cor.Y <- filter(cor.c.dat, Block == "Y") # Cytokine data
  cor.Y <- filter(cor.Y, names %in% y.features)
  
  # add metadata to X/Y dat
  cor.X <- join(cor.X, x.meta, by = "names")
  cor.X <- join(cor.X, fam.cols[,c("Family", "col")], by = "Family")
  
  cor.Y <- join(cor.Y, y.meta, by = "names")
  
  # make plot colours
  # phylum
  phylum.cols <- as.character(phy.cols$phylum.cols)
  names(phylum.cols) <- phy.cols$Phylum
  phylum.cols <- phylum.cols[which(names(phylum.cols) %in% cor.X$Phylum)]
  
  # family
  fam.c <- as.character(fam.cols$col)
  names(fam.c) <- fam.cols$Family
  fam.c <- fam.c[which(names(fam.c) %in% cor.X$Family)]
  
  # stim
  stimulus.cols <- as.character(stim.cols$stim.cols)
  names(stimulus.cols) <- stim.cols$Stim
  stimulus.cols <- stimulus.cols[which(names(stimulus.cols) %in% cor.Y$Stimulus)]
  
  # make your own correlation circle
  circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
    r = diameter / 2
    tt <- seq(0,2*pi,length.out = npoints)
    xx <- center[1] + r * cos(tt)
    yy <- center[2] + r * sin(tt)
    return(data.frame(x = xx, y = yy))
  }
  
  outer.circle <- circleFun(c(0,0),2,npoints = 100)
  inner.circle <- circleFun(c(0,0),1,npoints = 100)
  
  # plot
  # remove extra column from corX
  cor.X <- cor.X[,-7]
  cor.X$Family <- factor(cor.X$Family, levels = names(fam.c))
  
  p <- ggplot() +
    geom_path(data = outer.circle, aes(x = x, y = y)) +
    geom_path(data = inner.circle, aes(x = x, y = y)) +
    geom_point(data = cor.X, aes(x = x, y = y, colour = Family, size = sz), alpha = 0.7, size = 5, show.legend = TRUE, shape = 19) +
    #geom_text(data = cor.X, size = 3, aes(x = x, y = y, label = Genus), nudge_x = 0.12) +
    geom_point(data = cor.Y, aes(x = x, y = y, fill = Stimulus, size = 5), alpha = 0.7, show.legend = TRUE, shape = 24, size = 5, color = "white") +
    geom_text(data = cor.Y, size = 3, aes(x = x, y = y, label = Cytokine), check_overlap = TRUE, position = position_jitter(width = 0.2)) +
    geom_hline(yintercept = 0.0, linetype = "dashed", color = "grey") + 
    geom_vline(xintercept = 0.0, linetype = "dashed", color = "grey") + 
    theme_bw() + 
    labs(x = paste("Component", comps[1]), y = paste("Component", comps[2])) +
    scale_color_manual("OTU Family", values = c(fam.c),
                       guide = guide_legend(override.aes = list(colour = c(fam.c), shape = 19))) +
    scale_fill_manual("Stimulus",
                      values = c(stimulus.cols),
                      guide = guide_legend(override.aes = list(fill = c(stimulus.cols), shape = 24, colour = "white"))) +
    theme(panel.border = element_rect(size = 1.5),
          strip.background = element_rect(fill = "white", size = 1.5),
          strip.text.x = element_text(size = 12, face = "bold"),
          axis.text.x = element_text(size = 12, face = "bold"),
          axis.text.y = element_text(size = 12, face = "bold"),
          axis.title.x = element_text(size = 14),
          axis.title.y = element_text(size = 14),
          legend.text = element_text(size = 12),
          legend.title = element_text(size = 12))
  
  return(p)
}

# function spls.heatmap ####
# This function produces a heatmap of the correlation estimates.  It is written for the output of x.y.lm.scaled (function_pairwise_lm.R). 
# Input: lm.res: output of x.y.lm.scaled (function_pairwise_lm.R)
# x.vars: x.features to include in the plot
# y.vars: y features to include in the plot
# num.display: logical. If TRUE, displays the numbers in each heatmap cell
# spls.meta: output of get.feature.data()

hm.est <- function(lm.res, x.vars, y.vars, title, num.display, spls.meta){
  
  # Prepare results dataframe
  lm.res <- filter(lm.res, X.var %in% x.vars, Y.var %in% y.vars)
  
  # prepare data matrix
  lm.cast <- dcast(lm.res, X.var ~ Y.var, value.var = "Estimate")
  rownames(lm.cast) <- lm.cast$X.var
  lm.cast <- lm.cast[,-1]
  
  # Prepare row sidecolours: X
  row.meta <- spls.meta$X.meta
  row.meta <- join(row.meta, fam.cols[,c("Family", "col")], by = "Family")
  row.meta <- row.meta[,c("names", "Family", "col")]
  row.meta <- filter(row.meta, names %in% x.vars)
  rownames(row.meta) <- row.meta$names
  row.cols <- data.frame(row.meta[,c("Family")], row.names = row.meta$names)
  colnames(row.cols)[1] <- "Family"
  
  # Prepare row sidecolours: Y
  col.meta <- spls.meta$Y.meta[,c("names", "Stimulus", "stim.cols")]
  col.meta <- filter(col.meta, names %in% y.vars)
  rownames(col.meta) <- col.meta$names
  col.cols <- data.frame(col.meta[,c("Stimulus")], row.names = col.meta$names)
  colnames(col.cols)[1] <- "Stimulus"
  
  # make annotations 
  #Phyla
  row.annot <- row.meta[,c("Family", "col")]
  row.annot <- unique(row.annot)
  row.list <- as.character(row.annot$col)
  names(row.list) <- row.annot$Family
  
  #Stims
  col.annot <- col.meta[,c("Stimulus", "stim.cols")]
  col.annot <- unique(col.annot)
  col.list <- as.character(col.annot$stim.cols)
  names(col.list) <- col.annot$Stimulus
  
  # annotation colours
  annot.cols <- list(Family = c(row.list),
                     Stimulus = c(col.list))
  
  # set internal colors
  color.edge <- colorRampPalette(c("darkblue", "blue", "white", "red", "darkred"))
  breaks <- seq(from = -1, to = 1.01, by = 0.01)
  cell.cols <- color.edge(length(breaks)-1)
  
  # plot heatmap
  pheatmap(lm.cast,
           color = cell.cols,
           breaks = breaks,
           annotation_row = row.cols,
           annotation_col = col.cols,
           annotation_colors = annot.cols,
           display_numbers = num.display,
           fontsize_row = 8,
           fontsize_col = 8,
           main = title)
  
}

# function spls.rn ####
# This function produces a relevance network, coloring edges according to correlatoin strength
# Input: lm.res: output of x.y.lm.scaled (function_pairwise_lm.R)
# x.vars: character vector of x features to include
# y.vars: character vector of y features to include
# spls.meta: output of get.feature.data()

spls.rn <- function(lm.res, x.vars, y.vars, spls.meta){
  
  # Make edge list
  edge.list <- filter(lm.res, X.var %in% x.vars, Y.var %in% y.vars)
  
  edge.list <- edge.list[,c("X.var", "Y.var", "Estimate")]
  colnames(edge.list) <- c("from", "to", "weight")
  edge.list <- filter(edge.list, weight != 0)
  
  # make network
  net <- graph_from_data_frame(d = edge.list, directed = FALSE)
  
  # Make attribute data
  labs <- data.frame(V(net)$name)
  colnames(labs) <- "names"
  labs$type <- substr(labs$names, start = 1, stop = 1)
  labs$shape <- ifelse(labs$type == "O", "circle", "rectangle")
  
  # split into x/y and add more attributes
  labs.x <- filter(labs, type == "O")
  labs.y <- filter(labs, type != "O")
  
  # Add metadata: X
  x.meta <- spls.meta$X.meta
  labs.x <- join(labs.x, x.meta, by = "names")
  
  # get number of connections
  edge.list <- ddply(edge.list, .(from), transform, num.x.connections = length(from))
  n.x.connect <- edge.list[,c("from", "num.x.connections")]
  n.x.connect <- unique(n.x.connect)
  colnames(n.x.connect)[1] <- "names"
  
  labs.x <- join(labs.x, n.x.connect, by = "names")
  # add family cols
  labs.x <- join(labs.x, fam.cols, by = "Family")
  
  # get names, type, shape, label, and col
  labs.x.select <- labs.x[,c("names", "type", "shape", "Genus", "col", "num.x.connections")]
  colnames(labs.x.select)[4:6] <- c("label", "col", "n.connect")
  
  # Add metadata: Y
  y.meta <- spls.meta$Y.meta
  labs.y <- join(labs.y, y.meta, by = "names")
  
  colnames(stim.cols)[2] <- "Stimulus"
  labs.y <- join(labs.y, stim.cols[,c("Stimulus", "stim.cols")], by = "Stimulus")
  
  # get number of connections
  edge.list <- ddply(edge.list, .(to), transform, num.y.connections = length(to))
  n.y.connect <- edge.list[,c("to", "num.y.connections")]
  n.y.connect <- unique(n.y.connect)
  colnames(n.y.connect)[1] <- "names"
  
  labs.y <- join(labs.y, n.y.connect, by = "names")
  
  # get names, type, shape, label, and col
  labs.y.select <- labs.y[,c("names", "type", "shape", "Cytokine", "stim.cols", "num.y.connections")]
  colnames(labs.y.select)[4:6] <- c("label", "col", "n.connect")
  
  # join labs
  labs <- rbind(labs.x.select, labs.y.select)
  
  # set network attributes ####
  
  # vertex attributes
  V(net)$shape <- labs$shape
  
  V(net)$size <- 2*labs$n.connect # vertex size
  
  V(net)$color <- as.character(labs$col) # vertex colour
  
  V(net)$label <- as.character(labs$label) # vertex label
  
  V(net)$label.color <- "#252525" # label color
  
  V(net)$label.cex <- 0.5 # label font size
  
  V(net)$label.font <- 2 # bold font
  
  # set edge attributes 
  # colur
  color.edge <- colorRampPalette(c("darkblue", "blue", "white", "red", "darkred"))
  
  # create vector of weights from -1 to +1, jumping by 0.01, and assigning colours
  weight.round <- seq(from = -1, to = 1, by = 0.01)
  edge.cols <- color.edge(length(weight.round))
  edge.cols <- data.frame(weight.round, edge.cols)
  edge.cols$weight.round <- round(edge.cols$weight.round, digits = 2)
  
  # get rounded edge weights
  edge.list$weight.round <- round(edge.list$weight, digits = 2)
  edge.list <- join(edge.list, edge.cols, by = "weight.round")
  
  # change edge colours
  E(net)$color <- as.character(edge.list$edge.cols)
  
  # width
  E(net)$width <- 3*abs(edge.list$weight)
  
  # clean up 
  net <- simplify(net, remove.multiple = F, remove.loops = T)
  net <- delete.vertices(net, V(net)[ degree(net) < 2] ) # delete vertices with less than two connections
  
  # get data to return
  col.features <- c(as.character(labs.x$Family), as.character(labs.y$Stimulus))
  
  to.return <- list(net, col.features)
  names(to.return) <- c("net", "col.features")
 
  return(to.return)
  
}




